use crate::lang::{
    lexer::{Point, Span, Token},
    Clause, Predicate, Query, Value, ValueInner,
};

#[LALR]
grammar;

pub Query: Query = {
	<l: @L> <clauses: Clauses> "?-" <goal: Predicate> "." <r: @R> => {
		Query { clauses, goal, span: Span(l, r) }
	},
};

pub Clause: Clause = {
	<l: @L> <head: Predicate> "." <r: @R> => Clause { head, body: Vec::new(), span: Span(l, r) },
	<l: @L> <head: Predicate> ":-" <body: CS1PNPredicates> "." <r: @R> => {
		Clause { head, body, span: Span(l, r) }
	},
};

PNPredicate: (bool, Predicate) = {
	<p: Predicate> => (false, p),
	"!" <p: Predicate> => (true, p),
};

pub Predicate: Predicate = {
	<l: @L> <name: Var> "(" <args: CSValues> ")" <r: @R> => {
		Predicate { name, args, span: Span(l, r) }
	},
};

pub Value: Value = {
	<l: @L> "_" <r: @R> => Value { inner: ValueInner::Hole, span: Span(l, r) },
	<l: @L> <s: String> <r: @R> => Value { inner: ValueInner::Str(s), span: Span(l, r) },
	<l: @L> <v: Var> <r: @R> => Value { inner: ValueInner::Var(v), span: Span(l, r) },
};

Clauses: Vec<Clause> = {
	=> Vec::new(),
	<mut init: Clauses> <last: Clause> => {
		init.push(last);
		init
	}
};

CSValues: Vec<Value> = {
	=> Vec::new(),
	CS1Values => <>,
};

CS1Values: Vec<Value> = {
	Value => vec![<>],
	<mut init: CS1Values> "," <last: Value> => {
		init.push(last);
		init
	}
};

CS1PNPredicates: Vec<(bool, Predicate)> = {
	PNPredicate => vec![<>],
	<mut init: CS1PNPredicates> "," <last: PNPredicate> => {
		init.push(last);
		init
	}
};

extern {
	type Error = String;
	type Location = Point;

	enum Token {
    	")" => Token::ParenClose,
    	"(" => Token::ParenOpen,
		"_" => Token::Underscore,
    	"." => Token::Period,
    	"," => Token::Comma,
    	"?-" => Token::Query,
    	":-" => Token::Turnstile,
    	"!" => Token::Not,
    	String => Token::String(<String>),
    	Var => Token::Var(<String>),
	}
}

